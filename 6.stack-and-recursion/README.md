## Стек (Stack)

>Абстрактный тип данных, представляющий собой коллекцию элементов с принципом работы "последним пришел — первым ушел" (
  `LIFO — Last In, First Out`).
>
>В Python стек можно реализовать с помощью встроенного типа данных `list`, так как список поддерживает операции
  добавления и удаления элементов с конца.

>`push` — добавление элемента на вершину стека. 
> 
>В Python это можно сделать с помощью метода `append()`

## Стек как структура данных

### Пример:


```python
stack = []

# Добавление элементов (push)
stack.append(1)
stack.append(2)
stack.append(3)

print(stack)  # [1, 2, 3]

# Удаление элемента (pop)
popped_element = stack.pop()
print(popped_element)  # 3
print(stack)  # [1, 2]
```

#### Пример:

```python
numbers = [1, 2, 3, 4]
squared = map(lambda x: x ** 2, numbers)
print(list(squared))  # Вывод: [1, 4, 9, 16]
```

## Модуль sys

>Предоставляет функции и переменные, которые позволяют манипулировать интерпретатором Python,
  получать информацию о нем и контролировать его.

### `getrecursionlimit()`

>Возвращает текущий предел глубины рекурсии для интерпретатора Python. Это значит, что она показывает максимальное
  количество рекурсивных вызовов функций, которое Python может обработать перед тем, как произойдет ошибка переполнения
  стека (RecursionError).

### Пример:

```python
from sys import getrecursionlimit

# Получаем текущий предел рекурсии
current_limit = getrecursionlimit()
print(f"Текущий предел рекурсии: {current_limit}")
```
>
>Также в модуле sys есть функция `setrecursionlimit()`, которая позволяет изменить этот предел, хотя обычно не
>рекомендуется устанавливать его слишком высоко, так как это может привести к проблемам с памятью или даже к краху
>программы из-за переполнения стека.
>
>Использование `getrecursionlimit` может быть полезно для:
>
>- Отладки рекурсивных функций.
>- Оптимизации алгоритмов, которые могут быть рекурсивными.
>- Понимания ограничений текущей среды выполнения Python.

## Рекурсивная функция и Итеративная функция

>функция вычисления факториала через цикл может работать даже при превышении лимита рекурсии, в то время как
  рекурсивная функция ограничена этим лимитом.

### Рекурсивная реализация факториала

#### Пример:

```python
def factorial(n):
    if n <= 2:
        return n
    return n * factorial(n - 1)
```

>Каждый вызов этой функции создает новую запись в стеке вызовов. Если `n` больше текущего лимита рекурсии, то Python
  выдаст ошибку `RecursionError`, потому что стек вызовов переполнится. Например, если лимит рекурсии установлен на
  1000,
  и вы попытаетесь вычислить `factorial_recursive(1001)`, упадет ошибка.

### Итеративная реализация факториала

#### Пример:

```python
def factorial(n):
    result = 1

    for i in range(1, n + 1):
        result *= i
    return result
```

### Вот почему итеративная версия не сталкивается с лимитом рекурсии:

#### Использование памяти:

>Итеративная функция использует фиксированное количество памяти независимо от значения `n`.
  Переменная `result` и счетчик цикла i занимают постоянное место в памяти, вне зависимости от количества итераций.

#### Цикл вместо стека:

>Вместо создания новых записей в стеке вызовов для каждого шага вычисления, как это делает рекурсия,
  цикл просто обновляет текущее значение переменной `result`. Это означает, что независимо от того, сколько раз
  выполняется
  цикл, использование стека вызовов остается неизменным.

#### Лимит рекурсии не применяется:

>Лимит рекурсии касается только глубины вложенных вызовов функций. Циклы не создают новых
  уровней вызовов функций, поэтому они не ограничены лимитом рекурсии.

### Пример превышения лимита

Если установить лимит рекурсии в 100 с помощью `sys.setrecursionlimit(100)` и вычислить факториал числа
110:

#### Рекурсивно:

>- упадет `RecursionError`, потому что функция будет вызывать саму себя 110 раз, что превышает лимит в 100.

#### Итеративно:

>- успешно вычислится факториал 110, потому что цикл просто выполнится 110 раз, не создавая новых уровней в
  стеке вызовов.


>**Таким образом, итеративная реализация не сталкивается с проблемой лимита рекурсии, так как она не создает новых вызовов
функции для каждого шага вычисления.**


## Хвостовая рекурсия

>Это тип рекурсии, где вызов рекурсивной функции является последней операцией в функции.


#### Преимущества:

>Хвостовую рекурсию можно оптимизировать компилятором или интерпретатором, превращая ее в цикл, что предотвращает
  переполнение стека вызовов при обработке больших входных данных.

### Пример:

```python
def factorial(n, accumulator=1):
    """
    :param n: Факториал числа
    :param accumulator: Аккумулятор - накапливает результат
    :return: Хвостовой вызов (последняя операция в функции)
    """
    if n <= 2:
        return n * accumulator
    return factorial(n - 1, accumulator=accumulator * n)
```

>Стандартная рекурсивная функция для вычисления факториала. Здесь используется аргумент `accumulator`, который
  накапливает результат, что делает функцию хвостовой (последним действием функции является возврат результата вызова
  самой себя).
>
>Но так как Python не поддерживает оптимизацию хвостовой рекурсии, при больших значениях `n` эта функция приведет к
  переполнению стека вызовов.

## Класс TailCall и декоратор tail_recursion

```python
from functools import wraps
from typing import Any
from dataclasses import dataclass, field


@dataclass
class TailCall:
    """
    Специальный класс, который используется для того, чтобы сигнализировать, 
    что функция еще не завершена и необходимо продолжить выполнение с новыми аргументами.
    """
    args: tuple[Any, ...] = field(default_factory=tuple)
    kwargs: dict[str, Any] = field(default_factory=dict)


def tail_recursion(func):
    """
     Декоратор, который позволяет симулировать хвостовую рекурсию с помощью цикла while. 
     Он оборачивает рекурсивную функцию и, пока результат является экземпляром класса TailCall, 
     продолжает вызывать её без создания новых кадров стека.
    """

    @wraps(func)
    def wrapper(*args, **kwargs):
        result = TailCall(args, kwargs)

        while isinstance(result, TailCall):
            result = func(*result.args, **result.kwargs)
        return result

    return wrapper
```

## Функция tail

```python
def tail(*args, **kwargs):
    """
    Вспомогательная функция, которая возвращает объект класса TailCall. 
    Она используется в рекурсивной функции для возврата "заданных" аргументов, 
    с которыми функция должна быть вызвана на следующем шаге.
    """
    return TailCall(args, kwargs)
```

## Хвостовая рекурсия во второй версии `factorial`

```python
@tail_recursion
def factorial(n, accumulator=1):
    if n <= 2:
        return n * accumulator
    return tail(n - 1, accumulator=accumulator * n)
```

>Теперь функция `factorial` обёрнута декоратором `@tail_recursion`. Вместо того чтобы сразу вызывать функцию
  рекурсивно,
  она возвращает объект `TailCall`, который содержит аргументы для следующего вызова. Декоратор затем перехватывает этот
  объект и вызывает функцию с новыми аргументами, используя цикл `while`. Это предотвращает создание новых кадров стека
  и
  позволяет избежать переполнения стека.

### Пример:

```python
print(f'{factorial(100)=}')
```
>Здесь вызывается факториал от 100 с использованием хвостовой рекурсии, что эффективно предотвращает переполнение
  стека.

## Примеры с использованием reduce

**Примеры вычисления факториала с помощью функции reduce**

```python
from functools import reduce
from operator import mul

# факториал от 6
print(reduce(lambda a, b: a * b, range(1, 4)))

# факториал от 10
print(reduce(lambda a, b: a * b, range(1, 11)))

# более быстрый и короткий вариант записи для вычисления факториала от 10
print(reduce(mul, range(1, 11)))
```

>для вычисления факториала используется стандартная функция reduce из модуля `functools`. Факториал от n можно
  вычислить
  как произведение всех чисел `от 1 до n`, что и делает `reduce` с использованием либо анонимной
  функции `lambda a, b: a * b`,
  либо стандартной функции `mul` из модуля `operator`.

## Итог:

1. Первая часть кода реализует хвостовую рекурсию для вычисления факториала с помощью специального механизма (декоратор
   и класс TailCall)
2. Вторая часть кода демонстрирует вычисление факториала с использованием функции reduce.


>**Хвостовая рекурсия полезна тем, что позволяет выполнять рекурсивные вычисления без риска переполнения стека, а
reduce — это просто другая техника функционального программирования для достижения того же результата.**

