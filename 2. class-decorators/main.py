# Классы-декораторы
# Декораторы классов

# декоратор автоматически генерирует методы, такие как __init__, __repr__, и другие, для класса.
from dataclasses import dataclass

"""
декоратор автоматически создает методы __init__, __repr__, __eq__ и другие. 
Опция slots=True указывает Python использовать __slots__ вместо __dict__ для хранения атрибутов. 
Это оптимизирует использование памяти, но ограничивает возможность динамического добавления атрибутов.
"""


@dataclass(slots=True)
class User:
    """Класс пользователь с id и именем."""
    id: int
    username: str


user = User(id=1, username="John")

print(user)  # User(id=1, username='John')

"""
User.__slots__ выводит список слотов, которые определены для класса User. 
Слоты - это специальные атрибуты, которые хранятся в памяти более эффективно, чем словарь __dict__. 
В этом случае, слоты - это ('id', 'username').
"""
print(User.__slots__)

"""
User.mro() выводит список классов, которые наследуются классом User. 
Метод mro() возвращает список классов в порядке, в котором они будут поисках атрибутов. 
В этом случае, список - это (<class '__main__.User'>, <class 'object'>).
"""
print(User.mro())

"""
User.__dataclass_params__ выводит параметры класса данных, которые были переданы декоратору @dataclass. 
В этом случае, параметры - это {'slots': True}.
"""
print(User.__dataclass_params__)

"""
выводит строковое представление объекта user с помощью метода __repr__. Результат аналогичен выводу print(user).
"""
print(repr(user))


"""
MRO расшифровывается как Method Resolution Order (Порядок разрешения методов). 
Это термин в Python, который описывает порядок, в котором Python ищет методы и атрибуты в иерархии классов 
при их вызове или доступе.
"""


class A:
    def metodo(self):
        print("A.metodo")


class B(A):
    def metodo(self):
        print("B.metodo")


class C(A):
    def metodo(self):
        print("C.metodo")


class D(B, C):
    pass


print(D.mro())


# [<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]

'''
Пояснение:
Python сначала проверяет D, затем B, затем C, затем A и, наконец, object.
Если метод или атрибут не найден в D, Python ищет его в B, затем в C, и так далее.
Зачем это нужно:
Предсказуемость: MRO обеспечивает предсказуемое поведение при наследовании, особенно в сложных иерархиях классов.
Избежание конфликтов: MRO помогает разрешать конфликты, когда методы переопределяются в разных базовых классах.
'''


